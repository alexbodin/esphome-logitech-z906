esphome:
  name: z906
  friendly_name: Logitech Z906
  includes:
    - Z906.h
    - z906_component.h
    - z906_globals.h
  on_boot:
    priority: 800.0
    then:
      - lambda: |-
          ensure_z906_initialized(id(z906_uart));

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  encryption:
    key: !secret api_key

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap: {}

web_server:
  port: 80
  version: 3
  local: True

captive_portal:

# UART configuration for the protocol Z906
uart:
  id: z906_uart
  tx_pin: GPIO17 # PIN13 from Z906
  rx_pin: GPIO16 # PIN12 from Z906
  baud_rate: 57600
  data_bits: 8
  parity: ODD
  stop_bits: 1

switch:
  - platform: gpio
    pin: GPIO4
    inverted: true
    name: "Power Toggle"

button:
  - platform: restart
    name: "Restart ESP"

  - platform: template
    name: "Standby ON"
    on_press:
      - lambda: |-
          z906_device_global->standby_on();
          id(z906_power_state).update();

  - platform: template
    name: "Standby OFF"
    on_press:
      - lambda: |-
          z906_device_global->standby_off();
          id(z906_power_state).update();

  - platform: template
    name: "Volume Mute ON"
    on_press:
      - lambda: |-
          z906_device_global->mute_on();
          id(z906_mute_state).publish_state(1);

  - platform: template
    name: "Volume Mute OFF"
    on_press:
      - lambda: |-
          z906_device_global->mute_off();
          id(z906_mute_state).publish_state(0);

  # Input selection buttons
  #input 1 TRS
  - platform: template
    name: "Input 1 (3.5mm TRS, 6 channels)"
    on_press:
      - lambda: |-
          z906_device_global->input_1();
      - delay: 500ms
      - lambda: |-
          id(z906_input_active).update();

  # Input 2 (RCA, 2 channels)
  - platform: template
    name: "Input 2 (RCA, 2 channels)"
    on_press:
      - lambda: |-
          z906_device_global->input_2();
      - delay: 500ms
      - lambda: |-
          id(z906_input_active).update();

  # Input 3 (Optical)
  - platform: template
    name: "Input 3 (Optical)"
    on_press:
      - lambda: |-
          z906_device_global->input_3();
      - delay: 500ms
      - lambda: |-
          id(z906_input_active).update();

  # Input 4 (Optical)
  - platform: template
    name: "Input 4 (Optical)"
    on_press:
      - lambda: |-
          z906_device_global->input_4();
      - delay: 500ms
      - lambda: |-
          id(z906_input_active).update();

  # Input 5 (RCA, S/PDIF 75Ω coaxial) (not 100% sure, i cannot test it)
  - platform: template
    name: "Input 5 (COAXIAL)"
    on_press:
      - lambda: |-
          z906_device_global->input_5();
      - delay: 500ms
      - lambda: |-
          id(z906_input_active).update();

  # Input 6 AUX
  - platform: template
    name: "Input 6 (AUX)"
    on_press:
      - lambda: |-
          z906_device_global->input_aux();
      - delay: 500ms
      - lambda: |-
          id(z906_input_active).update();

  - platform: template
    name: "Volume Main Up"
    on_press:
      - lambda: |-
          z906_device_global->main_volume_up();
          id(z906_main_volume).update();

  - platform: template
    name: "Volume Main Down"
    on_press:
      - lambda: |-
          z906_device_global->main_volume_down();
          id(z906_main_volume).update();

  - platform: template
    name: "Volume Sub Up"
    on_press:
      - lambda: |-
          z906_device_global->sub_volume_up();
          id(z906_sub_volume).update();

  - platform: template
    name: "Volume Sub Down"
    on_press:
      - lambda: |-
          z906_device_global->sub_volume_down();
          id(z906_sub_volume).update();

  - platform: template
    name: "Volume Center Up"
    on_press:
      - lambda: |-
          z906_device_global->center_volume_up();
          id(z906_center_volume).update();

  - platform: template
    name: "Volume Center Down"
    on_press:
      - lambda: |-
          z906_device_global->center_volume_down();
          id(z906_center_volume).update();

  - platform: template
    name: "Volume Rear Up"
    on_press:
      - lambda: |-
          z906_device_global->rear_volume_up();
          id(z906_rear_volume).update();

  - platform: template
    name: "Volume Rear Down"
    on_press:
      - lambda: |-
          z906_device_global->rear_volume_down();
          id(z906_rear_volume).update();

  #Read full status command
  - platform: template
    name: "Read Full Status"
    on_press:
      - lambda: |-
          z906_device_global->get_full_status();

  # Effects
  - platform: template
    name: "Effect 3D"
    on_press:
      - lambda: |-
          z906_device_global->effect_3D();

  - platform: template
    name: "Effect 4.1"
    on_press:
      - lambda: |-
          z906_device_global->effect_41();

  - platform: template
    name: "Effect 2.1"
    on_press:
      - lambda: |-
          z906_device_global->effect_21();

  - platform: template
    name: "Effect Off"
    on_press:
      - lambda: |-
          z906_device_global->effect_no();

interval:
  - interval: 100ms
    then:
      - lambda: |-
          if (z906_device_global != nullptr) {
              z906_device_global->loop();
          }

sensor:
  - platform: template
    name: "Standby State"
    id: z906_power_state
    lambda: |-
      return z906_device_global->get_power_status();
    internal: true
    update_interval: never
  - platform: template
    name: "Input Active"
    id: z906_input_active
    lambda: |-
      return z906_device_global->get_current_input();
    update_interval: never
  - platform: template
    name: "Volume Main State"
    id: z906_main_volume
    lambda: |-
      return z906_device_global->get_main_volume();
    update_interval: never
  - platform: template
    name: "Volume Rear State"
    id: z906_rear_volume
    lambda: |-
      return z906_device_global->get_rear_volume();
    update_interval: never
  - platform: template
    name: "Volume Center State"
    id: z906_center_volume
    lambda: |-
      return z906_device_global->get_center_volume();
    update_interval: never
  - platform: template
    name: "Volume Sub State"
    id: z906_sub_volume
    lambda: |-
      return z906_device_global->get_sub_volume();
    update_interval: never
  - platform: template
    name: "Temperature"
    id: z906_temperature
    unit_of_measurement: "°C"
    lambda: |-
      return z906_device_global->get_temperature();
    update_interval: never
  - platform: template
    name: "Volume Mute State"
    id: z906_mute_state
    lambda: |-
      return 0;
    update_interval: never

binary_sensor:
  - platform: template
    name: "Standby State (ON/OFF)"
    lambda: |-
      return id(z906_power_state).state == 1;
    device_class: power

text:
  - platform: template
    name: "UART Binary Command"
    id: uart_command
    optimistic: true
    mode: text
    on_value:
      then:
        - lambda: |-
            std::vector<uint8_t> bytes;

            std::string input = x;

            // Replace commas with spaces
            for (auto &c : input) {
              if (c == ',') c = ' ';
            }

            const char* ptr = input.c_str();
            char* end;

            while (*ptr != '\0') {
              // Skip spaces
              while (*ptr == ' ') ptr++;

              if (*ptr == '\0') break;

              unsigned long value = strtoul(ptr, &end, 0);

              if (ptr == end) break;  // no conversion

              if (value <= 255) {
                bytes.push_back((uint8_t)value);
              }

              ptr = end;
            }

            if (!bytes.empty()) {
              // Flush RX buffer before sending command
              while (id(z906_uart).available() > 0) {
                uint8_t dummy;
                id(z906_uart).read_byte(&dummy);
              }
              delay(500);
              // Send command
              ESP_LOGI("z906", "Sending command: %d bytes", bytes.size());
              id(z906_uart).write_array(bytes.data(), bytes.size());
              ESP_LOGI("z906", "Sent %d bytes", bytes.size());
              // Wait for response
              delay(500);
              int available = id(z906_uart).available();
              ESP_LOGI("z906", "Bytes available after command: %d", available);
              if (available > 0) {
                std::vector<uint8_t> response(available);
                id(z906_uart).read_array(response.data(), available);
                std::string resp_str;
                for (size_t i = 0; i < response.size(); i++) {
                  char buf[4];
                  snprintf(buf, sizeof(buf), "%02X", response[i]);
                  resp_str += buf;
                  if (i < response.size() - 1) {
                    resp_str += " ";
                  }
                }
                ESP_LOGI("z906", "Response (hex): %s", resp_str.c_str());
              } else {
                ESP_LOGI("z906", "No response received after command.");
              }
            } else {
              ESP_LOGW("z906", "No valid bytes parsed");
            }
